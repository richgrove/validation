package util

import (
	"fmt"
	"sync"
	"time"
)

// reducer use ExecutorResult to collect the results generated by each executors
type ExecutorResult interface {
	CombineResult(result ExecutorResult) ExecutorResult
}

// Executor is a function to run on data, and return ExecutorResult to be collected
type Executor func(data interface{}) ExecutorResult

// Task executor, a high level task to be broken into small
// executors to run concurrently in the pipeline.
// The task data is a task-scope data, and
// the pipeline can be canceled with GetMaxTimeToCompleteInSecond(),
// but each started executor will be run to complete.
type AppTaskExecutor interface {
	GetTaskData() interface{}
	GetAllExecutors() []Executor
	GetMaxTimeToCompleteInSecond() int
}

// Establish the task pipeline
func ExecutAppTask(task AppTaskExecutor, result ExecutorResult) (ExecutorResult, error) {
	count := len(task.GetAllExecutors())
	in := make(chan interface{}, count)
	out := make(chan ExecutorResult)
	done := make(chan interface{})

	var wg sync.WaitGroup

	wg.Add(count)
	for _, executor := range task.GetAllExecutors() {
		// put the task in fan-out N executors, each runs a small processing unit.
		// Once complete, pass result to reducer
		go func(fn Executor, in <-chan interface{}, out chan<- ExecutorResult, done <-chan interface{}) {
			//wg.Add(1)
			defer wg.Done()

			select {
			case data := <-in:
				// call executor on data, and send result to out
				// executor() runs to complete
				out <- fn(data)
			case <-done:
				// cancellation occurs at close(done)
				return
			}
		}(executor, in, out, done)
	}

	cancelFlag := false
	maxTime := task.GetMaxTimeToCompleteInSecond()
	if maxTime > 0 {
		go func() {
			time.Sleep(time.Duration(maxTime) * time.Second)
			close(done)
			cancelFlag = true
		}()
	}

	go func() {
		// wait for all executors to complete, or cancel
		wg.Wait()
		// no more result data
		close(out)
	}()

	// executors start with task data
	for i := 0; i < count; i++ {
		in <- task.GetTaskData()
	}

	// reducer collects all results
	for r := range out {
		result = result.CombineResult(r)
	}
	if cancelFlag {
		return nil, fmt.Errorf("task execution canceled with configured duration %d", task.GetMaxTimeToCompleteInSecond())
	}
	return result, nil
}
